<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Advanced Stock Analysis</title>
  <!-- Include Plotly for Charting -->
  <script src="https://cdn.plot.ly/plotly-2.18.2.min.js"></script>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, #f3f4f6, #ffffff);
      color: #333;
      margin: 0 auto;
      max-width: 900px;
      padding: 2rem;
      line-height: 1.6;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-weight: 600;
    }
    p, li {
      margin-bottom: 0.75em;
    }
    label {
      display: block;
      margin-top: 15px;
      font-weight: 500;
    }
    input[type="text"],
    input[type="number"],
    input[type="date"] {
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.95rem;
      transition: border-color 0.3s ease;
    }
    button {
      margin-top: 20px;
      padding: 10px 20px;
      background: #2563eb;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    button:hover {
      background: #1e3a8a;
    }
    .section {
      margin-top: 30px;
      padding: 20px;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      background-color: #f9fafb;
    }
    .section h2 {
      margin-bottom: 10px;
      font-weight: 600;
    }
    /* Aggregated bar meter styles */
    #aggregateBar {
      position: relative;
      background: linear-gradient(to right, red, #ffcc00, green);
      height: 30px;
      border-radius: 15px;
      margin: 10px 0;
    }
    #aggregateMarker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 100%;
      background: black;
    }
    #aggregateScoreText {
      position: absolute;
      width: 100%;
      text-align: center;
      line-height: 30px;
      font-weight: bold;
      color: #fff;
      text-shadow: 1px 1px 2px #000;
    }
    #explanation {
      text-align: center;
      margin-top: 20px;
    }
    #techChart, #mcChart, #lrChart, #sentChart, #insiderChart {
      width: 100%;
      height: 400px;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      margin-top: 10px;
    }
    #loading {
      margin-top: 10px;
      font-style: italic;
      color: #f97316;
    }
    .flex-space {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
  </style>
</head>

<body>
  <!-- Back to Main Page button -->
  <button onclick="window.location.href='https://www.projectmanagerhelper.com'">Back to Main Page</button>

  <h1>Advanced Stock Analysis</h1>
  <p>Enter a ticker, select a historical period, and pick a future date. Click "Run Simulation" to analyze trends, technicals, sentiment, and insider trading.</p>

  <label for="ticker">Ticker Symbol (e.g. AAPL):</label>
  <input type="text" id="ticker" value="AAPL">
  
  <label for="period">Historical Period (months):</label>
  <input type="number" id="period" value="12" min="1">

  <label for="futureDate">Future Date:</label>
  <input type="date" id="futureDate">

  <button id="simulateButton">Run Simulation</button>
  <div id="loading" style="display:none;">Loading data and running simulation...</div>

  <!-- Aggregated Signal Bar Meter -->
  <div id="aggregateSection" class="section" style="display:none;">
    <h2>Aggregated Signal</h2>
    <div id="aggregateBar">
      <div id="aggregateMarker"></div>
      <span id="aggregateScoreText"></span>
    </div>
    <div class="flex-space">
      <span>Sell (35%)</span>
      <span>Buy (65%)</span>
    </div>
  </div>

  <!-- Monte Carlo -->
  <div id="mcSection" class="section" style="display:none;">
    <h2>Monte Carlo Simulation (GBM)</h2>
    <div id="mcChart"></div>
    <div id="mcDetails" style="margin-top:10px; font-weight:600;"></div>
    <div id="mcSlider" style="margin-top: 20px;"></div>
  </div>

  <!-- Linear Regression -->
  <div id="lrSection" class="section" style="display:none;">
    <h2>Linear Regression Forecast</h2>
    <div id="lrChart"></div>
    <div id="lrDetails" style="margin-top:10px; font-weight:600;"></div>
  </div>

  <!-- Combined Technical Indicators -->
  <div id="techSection" class="section" style="display:none;">
    <h2>Combined Technical Indicators</h2>
    <div id="techChart"></div>
    <div id="techDetails" style="margin-top:10px; font-weight:600;"></div>
  </div>

  <!-- Sentiment Analysis -->
  <div id="sentSection" class="section" style="display:none;">
    <h2>Sentiment Analysis</h2>
    <div id="sentChart"></div>
    <div id="sentDetails" style="margin-top:10px; font-weight:600;"></div>
  </div>

  <!-- Insider Trading -->
  <div id="insiderSection" class="section" style="display:none;">
    <h2>Insider Trading Activity</h2>
    <div id="insiderChart"></div>
    <div id="insiderDetails" style="margin-top:10px; font-weight:600;"></div>
    <button id="insiderLinkButton">More Insider Info</button>
  </div>

  <!-- Explanation Section (Button only) -->
  <div id="explanation">
    <button id="explanationButton">View Detailed Explanation</button>
  </div>

  <script>
    /*********************************************************
     * parseAlphaDate & processHistoricalData
     *********************************************************/
    function parseAlphaDate(str){
      const year  = str.substring(0,4);
      const month = str.substring(4,6);
      const day   = str.substring(6,8);
      const hour  = str.substring(9,11) || "00";
      const min   = str.substring(11,13)|| "00";
      const sec   = str.substring(13,15)|| "00";
      return new Date(`${year}-${month}-${day}T${hour}:${min}:${sec}Z`);
    }

    function processHistoricalData(timeSeries, periodMonths) {
      const dates = Object.keys(timeSeries).sort((a,b)=> new Date(a)- new Date(b));
      const endDate = new Date(dates[dates.length-1]);
      const startDate = new Date(endDate);
      startDate.setMonth(startDate.getMonth() - periodMonths);

      let prices=[];
      for(let date of dates){
        const dt= new Date(date);
        if(dt>= startDate && dt<= endDate){
          prices.push({
            date: dt,
            close: parseFloat(timeSeries[date]["5. adjusted close"])
          });
        }
      }
      prices.sort((a,b)=> a.date- b.date);
      return prices;
    }

    /*********************************************************
     * Monte Carlo Simulation
     *********************************************************/
    let globalFinalPrices = []; // Store final prices for slider updates

    // Utility to get median (50th percentile) of an array
    function getMedian(arr) {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 !== 0) {
        return sorted[mid];
      } else {
        return (sorted[mid - 1] + sorted[mid]) / 2;
      }
    }

    function randn_bm(){
      let u=0, v=0;
      while(u===0) u= Math.random();
      while(v===0) v= Math.random();
      return Math.sqrt(-2.0 * Math.log(u))* Math.cos(2.0* Math.PI*v);
    }
    function computeStats(prices){
      let logReturns=[];
      for(let i=1;i<prices.length;i++){
        let prev= prices[i-1].close;
        let curr= prices[i].close;
        logReturns.push(Math.log(curr/prev));
      }
      if(logReturns.length<1){
        return { mean:0, stdDev:0, lastPrice: prices[prices.length-1].close };
      }
      let dailyMean= logReturns.reduce((a,b)=>a+b,0)/logReturns.length;
      let variance= logReturns.reduce((sum,r)=> sum+(r-dailyMean)**2,0)/(logReturns.length-1);
      let dailyStdDev= Math.sqrt(variance);
      let tradingDays= 252;
      return {
        mean: dailyMean* tradingDays,
        stdDev: dailyStdDev* Math.sqrt(tradingDays),
        lastPrice: prices[prices.length-1].close
      };
    }
    function runMC(lastPrice, mean, stdDev, T, sims=10000){
      let finals=[];
      for(let i=0;i<sims;i++){
        let Z= randn_bm();
        let ST= lastPrice* Math.exp((mean- 0.5* stdDev**2)*T + stdDev* Math.sqrt(T)* Z);
        finals.push(ST);
      }
      return finals;
    }

    function updateMCChart(finalPrices, lastPrice){
      globalFinalPrices = finalPrices;

      let trace={
        x: finalPrices,
        type:'histogram',
        marker:{ color:'gray' }
      };
      let layout={
        title:"Monte Carlo Distribution of Final Prices",
        xaxis:{ title:"Price" },
        yaxis:{ title:"Frequency" }
      };
      Plotly.newPlot("mcChart",[trace], layout);

      // Probability final >= lastPrice
      let count= finalPrices.filter(p=> p>= lastPrice).length;
      let prob= (count/finalPrices.length)*100;
      document.getElementById('mcDetails').innerText=
        `Bullish Probability: ${prob.toFixed(2)}%`;

      // Create a vertical red line at the median
      const medianPrice = getMedian(finalPrices);
      Plotly.relayout("mcChart", {
        shapes: [{
          type: 'line',
          x0: medianPrice,
          x1: medianPrice,
          y0: 0,
          y1: 1,
          xref: 'x',
          yref: 'paper',
          line: { color: 'red', width: 2 }
        }]
      });

      // Insert slider HTML
      document.getElementById('mcSlider').innerHTML = `
        <label for="priceSlider">Price (move to see probability):</label>
        <input type="range"
               id="priceSlider"
               min="${Math.min(...finalPrices).toFixed(2)}"
               max="${Math.max(...finalPrices).toFixed(2)}"
               step="0.01"
               value="${medianPrice.toFixed(2)}"
               oninput="updateMCSlider(this.value)">
        <span id="sliderValue">${medianPrice.toFixed(2)}</span>
      `;

      return prob; // 0..100
    }

    function updateMCSlider(val) {
      val = parseFloat(val);
      document.getElementById('sliderValue').textContent = val.toFixed(2);

      let count = globalFinalPrices.filter(p => p >= val).length;
      let prob = (count / globalFinalPrices.length) * 100;
      document.getElementById('mcDetails').innerText =
        `Bullish Probability: ${prob.toFixed(2)}%`;

      Plotly.relayout("mcChart", {
        shapes: [{
          type: 'line',
          x0: val,
          x1: val,
          y0: 0,
          y1: 1,
          xref: 'x',
          yref: 'paper',
          line: { color: 'red', width: 2 }
        }]
      });
    }

    /*********************************************************
     * Linear Regression
     *********************************************************/
    function linearRegressionForecast(prices, futureDate){
      if(prices.length<2){
        return { forecastPrice: NaN, slope:0, intercept:0 };
      }
      let firstDate= prices[0].date;
      let xs= prices.map(p=> (p.date- firstDate)/(1000*60*60*24));
      let ys= prices.map(p=> p.close);
      let n= xs.length;
      let sumX= xs.reduce((a,b)=>a+b,0);
      let sumY= ys.reduce((a,b)=>a+b,0);
      let sumXY= xs.reduce((acc,x,i)=> acc+ x*ys[i], 0);
      let sumX2= xs.reduce((acc,x)=> acc+ x*x, 0);
      let slope= (n* sumXY - sumX* sumY)/(n* sumX2 - sumX* sumX);
      let intercept= (sumY- slope* sumX)/n;
      let futureX= (futureDate- firstDate)/(1000*60*60*24);
      let forecastPrice= intercept + slope* futureX;
      return { forecastPrice, slope, intercept };
    }
    function updateLRChart(prices, forecastPrice, futureDate){
      let currentPrice= prices[prices.length-1].close;
      let traceHist={
        x: prices.map(p=> p.date),
        y: prices.map(p=> p.close),
        mode:'lines+markers',
        name:'Historical'
      };
      let traceForecast={
        x: [prices[prices.length-1].date, futureDate],
        y: [currentPrice, forecastPrice],
        mode:'lines+markers',
        name:'Forecast'
      };
      let layout={
        title:"Linear Regression Forecast",
        xaxis:{ title:"Date" },
        yaxis:{ title:"Price" }
      };
      Plotly.newPlot("lrChart",[traceHist,traceForecast], layout);

      // 0..100 bullish measure
      let ratio= forecastPrice/ currentPrice;
      let bullScore= (ratio-1)*50 + 50;
      bullScore= Math.min(100, Math.max(0,bullScore));
      document.getElementById('lrDetails').innerText=
        `Forecast: $${forecastPrice.toFixed(2)} | Bullish Score: ${bullScore.toFixed(2)}%`;
      return bullScore;
    }

    /*********************************************************
     * Combined Technical Indicators
     *********************************************************/
    function computeBollingerBands(prices, period=20, k=2){
      let bands=[];
      for(let i=period-1;i<prices.length;i++){
        let slice= prices.slice(i-period+1,i+1).map(p=>p.close);
        let sma= slice.reduce((a,b)=>a+b,0)/ period;
        let variance= slice.reduce((sum,val)=> sum+ (val- sma)**2,0)/ period;
        let std= Math.sqrt(variance);
        bands.push({
          date: prices[i].date,
          sma,
          upper: sma+ k* std,
          lower: sma- k* std
        });
      }
      return bands;
    }
    function computeWMA(prices, period=20){
      let wmas=[];
      for(let i=period-1; i< prices.length; i++){
        let slice= prices.slice(i-period+1, i+1).map(p=> p.close);
        let numerator=0, denominator=0;
        for(let j=0;j<period;j++){
          let weight= j+1;
          numerator+= slice[j]*weight;
          denominator+= weight;
        }
        wmas.push({ date:prices[i].date, wma: numerator/ denominator });
      }
      return wmas;
    }
    function computeRSI(prices, period=14){
      let rsis=[];
      for(let i=period;i< prices.length;i++){
        let gains=0, losses=0;
        for(let j=i-period+1; j<= i; j++){
          let diff= prices[j].close- prices[j-1].close;
          if(diff>0) gains+= diff;
          else losses-= diff;
        }
        let avgGain= gains/period;
        let avgLoss= losses/period;
        let rs= (avgLoss===0)? 100: (avgGain/ avgLoss);
        let rsi= 100- (100/(1+ rs));
        rsis.push({ date: prices[i].date, rsi });
      }
      return rsis;
    }
    function computeEMA(prices, period){
      let ema=[];
      let multi= 2/(period+1);
      let sum=0;
      for(let i=0;i< period;i++){
        sum+= prices[i].close;
      }
      let prevEma= sum/ period;
      ema[period-1]= { date: prices[period-1].date, ema: prevEma };
      for(let i=period;i< prices.length;i++){
        let cur= prices[i].close;
        let next= (cur- prevEma)* multi+ prevEma;
        ema[i]= { date: prices[i].date, ema: next };
        prevEma= next;
      }
      return ema.filter(x=> x!== undefined);
    }
    function computeMACD(prices, fast=12, slow=26, signal=9){
      let fastEMA= computeEMA(prices, fast);
      let slowEMA= computeEMA(prices, slow);
      let macdLine=[];
      for(let i=0;i< slowEMA.length;i++){
        let date= slowEMA[i].date;
        let match= fastEMA.find(f=> f.date.getTime()=== date.getTime());
        if(match){
          macdLine.push({ date, macd: match.ema- slowEMA[i].ema });
        }
      }
      if(macdLine.length< signal) return { macdLine, signalLine: [] };

      let signalLine=[];
      let m= 2/(signal+1);
      let sumMacd=0;
      for(let i=0;i< signal;i++){
        sumMacd+= macdLine[i].macd;
      }
      let prevSig= sumMacd/ signal;
      signalLine[signal-1]= { date: macdLine[signal-1].date, signal: prevSig };
      for(let i=signal;i< macdLine.length;i++){
        let s= (macdLine[i].macd- prevSig)*m + prevSig;
        signalLine[i]= { date: macdLine[i].date, signal: s };
        prevSig= s;
      }
      signalLine= signalLine.filter(x=> x!== undefined);
      return { macdLine, signalLine };
    }

    // Scoring (1..7)
    function getScoreRSI(val){
      if(val<=20) return 7;
      else if(val<=30) return 6;
      else if(val<=40) return 5;
      else if(val<=60) return 4;
      else if(val<=70) return 3;
      else if(val<=80) return 2;
      else return 1;
    }
    function getScoreBollinger(price, band){
      let range= band.upper- band.lower;
      if(range<=0) return 4; // fallback neutral
      let pctB= (price- band.lower)/ range;
      if(pctB< 0) return 7;
      else if(pctB< 0.2) return 6;
      else if(pctB< 0.4) return 5;
      else if(pctB< 0.6) return 4;
      else if(pctB< 0.8) return 3;
      else if(pctB< 1.0) return 2;
      else return 1;
    }
    function getScoreMACD(macd, signal){
      let diff= macd- signal;
      let score= 4; // neutral
      if(macd> 0) score++;
      if(macd> 1) score++;

      if(diff> 0.5) score+= 2;
      else if(diff> 0) score++;
      else if(diff< -0.5) score-= 2;
      else if(diff< 0) score--;

      if(score<1) score=1;
      if(score>7) score=7;
      return score;
    }
    function getScoreWMA(price, wmaVal){
      let diff= (price- wmaVal)/ wmaVal;
      let base=4;
      if(diff>= 0.05) base=7;
      else if(diff>= 0.02) base=6;
      else if(diff> 0) base=5;
      else if(Math.abs(diff)<0.005) base=4;
      else if(diff> -0.02) base=3;
      else if(diff> -0.05) base=2;
      else base=1;
      return base;
    }

    function updateTechChart(prices){
      let bands= computeBollingerBands(prices);
      let wmas= computeWMA(prices);
      let rsis= computeRSI(prices);
      let macdData= computeMACD(prices);

      // Plot
      let priceTrace={
        x: prices.map(p=>p.date),
        y: prices.map(p=>p.close),
        mode:'lines',
        name:'Price',
        xaxis:'x',
        yaxis:'y'
      };
      let smaTrace={
        x: bands.map(b=> b.date),
        y: bands.map(b=> b.sma),
        mode:'lines',
        line:{ dash:'dash', color:'#555'},
        name:'Bollinger SMA'
      };
      let upperTrace={
        x: bands.map(b=> b.date),
        y: bands.map(b=> b.upper),
        mode:'lines',
        line:{ color:'red'},
        name:'UpperBand'
      };
      let lowerTrace={
        x: bands.map(b=> b.date),
        y: bands.map(b=> b.lower),
        mode:'lines',
        line:{ color:'red'},
        name:'LowerBand'
      };
      let wmaTrace={
        x: wmas.map(w=> w.date),
        y: wmas.map(w=> w.wma),
        mode:'lines',
        line:{ color:'orange'},
        name:'WMA'
      };
      let macdTrace={
        x: macdData.macdLine.map(m=> m.date),
        y: macdData.macdLine.map(m=> m.macd),
        mode:'lines',
        name:'MACD',
        xaxis:'x2',
        yaxis:'y2'
      };
      let signalTrace={
        x: macdData.signalLine.map(s=> s.date),
        y: macdData.signalLine.map(s=> s.signal),
        mode:'lines',
        name:'Signal',
        xaxis:'x2',
        yaxis:'y2'
      };
      let rsiTrace={
        x: rsis.map(r=> r.date),
        y: rsis.map(r=> r.rsi),
        mode:'lines',
        name:'RSI',
        xaxis:'x3',
        yaxis:'y3'
      };

      let layout={
        grid:{ rows:3, columns:1, roworder:'top to bottom'},
        margin:{ t:80 },
        xaxis:{ domain:[0,1], anchor:'y', title:'Date'},
        yaxis:{ domain:[0.55,1], title:'Price'},
        xaxis2:{ domain:[0,1], anchor:'y2', title:'Date'},
        yaxis2:{ domain:[0.3, 0.55], title:'MACD'},
        xaxis3:{ domain:[0,1], anchor:'y3', title:'Date'},
        yaxis3:{ domain:[0,0.3], title:'RSI'},
        shapes:[
          {
            type:'line',
            xref:'x3', yref:'y3',
            x0: Math.min(...rsis.map(r=> r.date)),
            x1: Math.max(...rsis.map(r=> r.date)),
            y0:30, y1:30,
            line:{ dash:'dash', color:'red'}
          },
          {
            type:'line',
            xref:'x3', yref:'y3',
            x0: Math.min(...rsis.map(r=> r.date)),
            x1: Math.max(...rsis.map(r=> r.date)),
            y0:70, y1:70,
            line:{ dash:'dash', color:'red'}
          }
        ],
        title:"Combined Technical Indicators"
      };
      Plotly.newPlot('techChart', [
        priceTrace, smaTrace, upperTrace, lowerTrace,
        wmaTrace, macdTrace, signalTrace, rsiTrace
      ], layout);

      // Score
      if(prices.length<26){
        document.getElementById('techDetails').innerText=
          "Not enough data (26+ days recommended). ~50% (Neutral).";
        return 50;
      }
      let latestPrice= prices[prices.length-1].close;
      let band= bands[bands.length-1];
      let wmaVal= wmas[wmas.length-1].wma;
      let rsiVal= rsis[rsis.length-1].rsi;
      let macdVal= macdData.macdLine[macdData.macdLine.length-1].macd;
      let sigVal= macdData.signalLine[macdData.signalLine.length-1].signal;
      let diffMACD= macdVal- sigVal;

      let sRSI= getScoreRSI(rsiVal);
      let sBB= getScoreBollinger(latestPrice, band);
      let sMACD= getScoreMACD(macdVal, sigVal);
      let sWMA= getScoreWMA(latestPrice, wmaVal);

      let avgScore= (sRSI+ sBB+ sMACD+ sWMA)/4;
      let bullPct= ((avgScore-1)/6)* 100;
      document.getElementById('techDetails').innerText=
        `RSI=${rsiVal.toFixed(2)}, Boll.Score=${sBB}, MACD diff=${diffMACD.toFixed(2)}, WMA Score=${sWMA} => Bullish ${bullPct.toFixed(1)}%`;
      return bullPct;
    }

    /*********************************************************
     * Sentiment Analysis
     *********************************************************/
    async function fetchSentimentData(ticker, periodMonths){
      let url= `https://www.projectmanagerhelper.com/api/sentiment?symbol=${ticker}&periodMonths=${periodMonths}`;
      let resp= await fetch(url);
      let data= await resp.json();
      if(!data.feed) throw new Error("No sentiment data from server.");

      let startDate= new Date();
      startDate.setMonth(startDate.getMonth()- periodMonths);
      let byHour={};
      for(let article of data.feed){
        let dt= parseAlphaDate(article.time_published);
        if(isNaN(dt) || dt< startDate) continue;
        if(!article.ticker_sentiment) continue;
        let tItem= article.ticker_sentiment.find(ts=> ts.ticker.toUpperCase()=== ticker.toUpperCase());
        if(!tItem) continue;
        let raw= parseFloat(tItem.ticker_sentiment_score);
        if(isNaN(raw)) continue;
        let norm= ((raw+1)/2)*100;
        let hourKey= dt.toISOString().substring(0,13);
        if(!byHour[hourKey]) byHour[hourKey]=[];
        byHour[hourKey].push(norm);
      }
      let sentiments=[];
      for(let hStr in byHour){
        let vals= byHour[hStr];
        let avg= vals.reduce((a,b)=>a+b,0)/ vals.length;
        let dt= new Date(`${hStr}:00:00Z`);
        sentiments.push({ date: dt, sentiment: avg });
      }
      sentiments.sort((a,b)=> a.date- b.date);
      return sentiments;
    }
    function updateSentimentChart(sentiments){
      let traceRaw={
        x: sentiments.map(s=> s.date),
        y: sentiments.map(s=> s.sentiment),
        mode:'markers+lines',
        name:'Sentiment'
      };
      if(sentiments.length<2){
        Plotly.newPlot("sentChart",[traceRaw], {
          title:"Sentiment Analysis",
          xaxis:{ title:"Date"},
          yaxis:{ title:"Sentiment (0..100)"}
        });
        document.getElementById('sentDetails').innerText= "Insufficient data => 50% default.";
        return 50;
      }
      let firstDate= sentiments[0].date;
      let xs= sentiments.map(s=> (s.date- firstDate)/(1000*60*60*24));
      let ys= sentiments.map(s=> s.sentiment);
      let n= xs.length;
      let sumX= xs.reduce((a,b)=>a+b,0);
      let sumY= ys.reduce((a,b)=>a+b,0);
      let sumXY= xs.reduce((acc,x,i)=> acc+ x* ys[i],0);
      let sumX2= xs.reduce((acc,x)=> acc+ x*x,0);
      let slope= (n* sumXY - sumX* sumY)/(n* sumX2 - sumX* sumX);
      let intercept= (sumY- slope* sumX)/ n;

      let minDate= sentiments[0].date;
      let maxDate= sentiments[sentiments.length-1].date;
      let xMin= xs[0];
      let xMax= xs[xs.length-1];
      let yMin= intercept+ slope*xMin;
      let yMax= intercept+ slope*xMax;
      let traceTrend={
        x:[minDate, maxDate],
        y:[yMin, yMax],
        mode:'lines',
        line:{ dash:'dash', color:'red'},
        name:'Trend'
      };
      let layout={
        title:"Sentiment Analysis",
        xaxis:{ title:"Date"},
        yaxis:{ title:"Sentiment (0..100)"}
      };
      Plotly.newPlot("sentChart",[traceRaw, traceTrend], layout);
      let slopeBull= slope* 5+ 50;
      slopeBull= Math.min(100, Math.max(0, slopeBull));
      document.getElementById('sentDetails').innerText=
        `Slope: ${slope.toFixed(3)} => Bullish Score: ${slopeBull.toFixed(2)}%`;
      return slopeBull;
    }

    /*********************************************************
     * Insider Trading
     *********************************************************/
    async function fetchInsiderData(ticker, periodMonths){
      const url = `https://www.projectmanagerhelper.com/api/insider?symbol=${ticker}`;
      const resp = await fetch(url);
      const data = await resp.json();
      if(!data.data || !Array.isArray(data.data)){
        throw new Error("No insider data array found in the response");
      }

      const now = new Date();
      const cutoff = new Date();
      cutoff.setMonth(cutoff.getMonth() - periodMonths);

      let totalBuys = 0;
      let totalSells = 0;
      data.data.forEach(item => {
        if(!item.transaction_date || !item.acquisition_or_disposal || !item.shares) return;
        const dt = new Date(item.transaction_date);
        if(dt >= cutoff && !isNaN(dt)){
          const shares = parseFloat(item.shares);
          if(item.acquisition_or_disposal === "A"){
            totalBuys += shares;
          } else if(item.acquisition_or_disposal === "D"){
            totalSells += shares;
          }
        }
      });
      return { totalBuys, totalSells };
    }
    function updateInsiderChart(totalBuys, totalSells){
      const trace = {
        x: ["Bought", "Sold"],
        y: [totalBuys, totalSells],
        type: "bar",
        marker: {
          color: ["green", "red"]
        }
      };
      const layout = {
        title: "Insider Activity (Shares Bought vs. Sold)"
      };
      Plotly.newPlot("insiderChart", [trace], layout);

      let sum = totalBuys + totalSells;
      let insiderBull = 50;
      if(sum > 0){
        insiderBull = ((totalBuys - totalSells) / sum) * 50 + 50;
      }
      document.getElementById("insiderDetails").innerText =
        `Insider Bullish Score: ${insiderBull.toFixed(2)}%`;
      return insiderBull;
    }

    /*********************************************************
     * MAIN
     *********************************************************/
    document.getElementById("simulateButton").addEventListener("click", async()=>{
      document.getElementById('loading').style.display='block';
      document.getElementById('aggregateSection').style.display='none';
      document.getElementById('mcSection').style.display='none';
      document.getElementById('lrSection').style.display='none';
      document.getElementById('techSection').style.display='none';
      document.getElementById('sentSection').style.display='none';
      document.getElementById('insiderSection').style.display='none';

      let ticker= document.getElementById('ticker').value.trim();
      let periodMonths= parseInt(document.getElementById('period').value);
      let futureDateStr= document.getElementById('futureDate').value;
      if(!ticker || !futureDateStr){
        alert("Please enter both a ticker symbol and a future date.");
        document.getElementById('loading').style.display='none';
        return;
      }
      let futureDate= new Date(futureDateStr);

      try {
        let histUrl= `https://www.projectmanagerhelper.com/api/historical?symbol=${ticker}`;
        let resp= await fetch(histUrl);
        let data= await resp.json();
        if(!data["Time Series (Daily)"]){
          throw new Error("Unable to retrieve valid historical data.");
        }
        let prices= processHistoricalData(data["Time Series (Daily)"], periodMonths);
        if(prices.length< 2){
          alert("Not enough historical data for that period.");
          document.getElementById('loading').style.display='none';
          return;
        }

        let mcStats= computeStats(prices);
        let lastDate= prices[prices.length-1].date;
        let T= (futureDate- lastDate)/(365*24*60*60*1000);
        let mcFinals= runMC(mcStats.lastPrice, mcStats.mean, mcStats.stdDev, T);
        document.getElementById('mcSection').style.display='block';
        let mcBull= updateMCChart(mcFinals, mcStats.lastPrice);

        let lrRes= linearRegressionForecast(prices, futureDate);
        document.getElementById('lrSection').style.display='block';
        let lrBull= updateLRChart(prices, lrRes.forecastPrice, futureDate);

        document.getElementById('techSection').style.display='block';
        let techBull= updateTechChart(prices);

        let sentiments= await fetchSentimentData(ticker, periodMonths);
        document.getElementById('sentSection').style.display='block';
        let sentBull= updateSentimentChart(sentiments);

        let insiderObj = await fetchInsiderData(ticker, periodMonths);
        document.getElementById('insiderSection').style.display='block';
        let insiderBull= updateInsiderChart(insiderObj.totalBuys, insiderObj.totalSells);

        let aggregatedBull= (mcBull + lrBull + techBull + sentBull + insiderBull)/5;
        document.getElementById('aggregateSection').style.display='block';
        let normScore = ((aggregatedBull - 35) / 30) * 100;
        normScore = Math.min(100, Math.max(0, normScore));
        document.getElementById('aggregateMarker').style.left = normScore + '%';
        document.getElementById('aggregateScoreText').innerText = aggregatedBull.toFixed(2) + '%';
      }
      catch(err){
        alert("Error: "+err.message);
      }
      document.getElementById('loading').style.display='none';
    });

    // Explanation button
    document.getElementById("explanationButton").addEventListener("click", ()=>{
      window.location.href = "detailed_explanation.html";
    });

    // Insider link button
    document.getElementById("insiderLinkButton").addEventListener("click", ()=>{
      let ticker = document.getElementById("ticker").value.trim();
      if(ticker){
        window.open("https://www.projectmanagerhelper.com/insider/?symbol=" + encodeURIComponent(ticker) + "&days=30", "_blank");
      } else {
        alert("Please enter a ticker symbol.");
      }
    });
  </script>
</body>
</html>
