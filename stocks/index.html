<!DOCTYPE html>
<html>
<head>
  <title>Advanced Stock Price Prediction Tool</title>
  <!-- Include Plotly for interactive charts -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    /* Basic Reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, #f3f4f6, #ffffff);
      color: #333;
      margin: 0;
      padding: 0;
    }

    .container {
      max-width: 900px;
      margin: 40px auto;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 30px;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-weight: 600;
    }

    p {
      font-size: 0.95rem;
      line-height: 1.4;
      margin-bottom: 20px;
      color: #555;
    }

    label {
      display: block;
      margin-top: 15px;
      font-weight: 500;
    }

    input[type="text"],
    input[type="number"],
    input[type="date"],
    select {
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.95rem;
      transition: border-color 0.3s ease;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    input[type="date"]:focus,
    select:focus {
      outline: none;
      border-color: #6b7280;
    }

    button {
      margin-top: 20px;
      padding: 10px 20px;
      background: #2563eb;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    button:hover {
      background: #1e3a8a;
    }

    #loading {
      margin-top: 10px;
      font-style: italic;
      color: #f97316;
    }

    #result {
      margin-top: 30px;
    }

    #chart {
      width: 100%;
      height: 500px;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
      background-color: #fff;
    }

    #sliderDiv {
      margin-top: 20px;
    }

    #sliderDiv label {
      margin: 0;
      font-weight: 500;
    }

    #priceSlider {
      width: 80%;
      margin: 10px 0;
    }

    #thresholdValue {
      font-weight: 600;
      color: #2563eb;
    }

    #probability {
      font-weight: 600;
      color: #2563eb;
    }

    #explanation {
      margin-top: 30px; 
      padding: 20px; 
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      background-color: #f9fafb;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }

    #explanation h3 {
      margin-bottom: 10px;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <!-- Back to Main Page button -->
<button onclick="window.location.href='https://projectmanagerhelper.com'">
  Back to Main Page
</button>
  <div class="container">
    <h1>Advanced Stock Price Prediction Tool</h1>
    <p>
      Enter a ticker symbol (e.g., AAPL), the historical period (in months) to consider, select a future date, and choose a forecasting method.
      The tool uses advanced techniques to predict the future stock price and then generates an explanation of the methods and math used.
    </p>
    
    <label for="ticker">Ticker Symbol (e.g., AAPL):</label>
    <input type="text" id="ticker" value="AAPL">
    
    <label for="period">Historical Period (in months):</label>
    <input type="number" id="period" value="12" min="1">
    
    <label for="futureDate">Future Date:</label>
    <input type="date" id="futureDate">
    
    <label for="forecastMethod">Forecast Method:</label>
    <select id="forecastMethod">
      <option value="mc">Monte Carlo Simulation (GBM)</option>
      <option value="lr">Linear Trend Forecast</option>
      <option value="ensemble">Ensemble Forecast (Average of MC &amp; LR)</option>
    </select>
    
    <button id="simulateButton">Run Simulation</button>
    <div id="loading" style="display:none;">Loading data and running simulation...</div>
    
    <div id="result">
      <div id="chart"></div>
      <!-- Slider for Monte Carlo histogram (if applicable) -->
      <div id="sliderDiv" style="display:none;">
        <label for="priceSlider">Select Price Threshold:</label>
        <input type="range" id="priceSlider" min="0" max="1000" step="1" value="0">
        <span id="thresholdValue">0</span>
        <p>Probability of final price above threshold: <span id="probability">0%</span></p>
      </div>
    </div>
    
    <div id="explanation"></div>
  </div>
  
  <script>
    // 1. Generate a standard normal random variable (Box-Muller Transform)
    function randn_bm() {
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // 2. Fetch historical stock data from Alpha Vantage
    async function fetchHistoricalData(ticker) {
      // Replace with your valid Alpha Vantage API key
      const apiKey = 'YOUR_API_KEY';
      const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${ticker}&outputsize=full&apikey=${apiKey}`;
      
      const response = await fetch(url);
      const data = await response.json();
      if (data["Error Message"] || !data["Time Series (Daily)"]) {
        throw new Error("Error fetching data. Check ticker symbol or API key.");
      }
      return data["Time Series (Daily)"];
    }

    // 3. Process historical data to extract prices within the desired period
    function processHistoricalData(timeSeries, periodMonths) {
      const dates = Object.keys(timeSeries).sort((a, b) => new Date(a) - new Date(b));
      const endDate = new Date(dates[dates.length - 1]);
      const startDate = new Date(endDate);
      startDate.setMonth(startDate.getMonth() - periodMonths);
      
      let prices = [];
      for(let date of dates) {
        const currentDate = new Date(date);
        if(currentDate >= startDate && currentDate <= endDate) {
          prices.push({
            date: currentDate,
            close: parseFloat(timeSeries[date]["4. close"])
          });
        }
      }
      // Ensure ascending order
      prices.sort((a, b) => a.date - b.date);
      return prices;
    }

    // 4. Compute daily log returns, then annualize them for Monte Carlo
    function computeStats(prices) {
      let logReturns = [];
      for(let i = 1; i < prices.length; i++) {
        const prev = prices[i-1].close;
        const curr = prices[i].close;
        logReturns.push(Math.log(curr / prev));
      }
      if (logReturns.length < 1) {
        return { mean: 0, stdDev: 0, lastPrice: prices[prices.length - 1].close };
      }

      // daily mean and daily std dev
      const dailyMean = logReturns.reduce((a, b) => a + b, 0) / logReturns.length;
      const variance = logReturns.reduce((sum, r) => sum + Math.pow(r - dailyMean, 2), 0) / (logReturns.length - 1);
      const dailyStdDev = Math.sqrt(variance);

      // annualize (assume ~252 trading days/year)
      const tradingDaysPerYear = 252;
      const annualMean = dailyMean * tradingDaysPerYear;
      const annualStdDev = dailyStdDev * Math.sqrt(tradingDaysPerYear);

      return {
        mean: annualMean,
        stdDev: annualStdDev,
        lastPrice: prices[prices.length - 1].close
      };
    }

    // 5. Run Monte Carlo simulation using GBM
    function runSimulation(lastPrice, mean, stdDev, T, numSimulations = 10000) {
      let finalPrices = [];
      for(let i = 0; i < numSimulations; i++) {
        const Z = randn_bm();
        // mean & stdDev are annual, T in years
        const ST = lastPrice * Math.exp((mean - 0.5 * stdDev * stdDev) * T + stdDev * Math.sqrt(T) * Z);
        finalPrices.push(ST);
      }
      return finalPrices;
    }

    // 6. Linear regression forecast using least squares
    function linearRegressionForecast(prices, futureDate) {
      if(prices.length < 2) {
        return { forecastPrice: NaN, slope: 0, intercept: 0 };
      }
      const firstDate = prices[0].date;
      let xs = prices.map(p => (p.date - firstDate) / (1000 * 60 * 60 * 24)); // in days
      let ys = prices.map(p => p.close);
      const n = xs.length;
      const sumX = xs.reduce((a, b) => a + b, 0);
      const sumY = ys.reduce((a, b) => a + b, 0);
      const sumXY = xs.reduce((sum, x, i) => sum + x * ys[i], 0);
      const sumX2 = xs.reduce((sum, x) => sum + x * x, 0);
      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;
      const futureX = (futureDate - firstDate) / (1000 * 60 * 60 * 24);
      const forecastPrice = intercept + slope * futureX;
      return { forecastPrice, slope, intercept };
    }

    // 7. Plotting the Monte Carlo histogram + slider
    function updateChartMC(finalPrices) {
      const trace = {
        x: finalPrices,
        type: 'histogram',
        marker: { color: '#7f7f7f' }
      };
      const layout = {
        title: 'Simulated Final Stock Prices Distribution (Monte Carlo - GBM)',
        xaxis: { title: 'Price' },
        yaxis: { title: 'Frequency' }
      };
      Plotly.newPlot('chart', [trace], layout);

      document.getElementById('sliderDiv').style.display = 'block';
      const minPrice = Math.floor(Math.min(...finalPrices));
      const maxPrice = Math.ceil(Math.max(...finalPrices));
      const slider = document.getElementById('priceSlider');
      slider.min = minPrice;
      slider.max = maxPrice;
      slider.value = minPrice;
      document.getElementById('thresholdValue').innerText = minPrice;
      updateProbability(finalPrices, minPrice);
      slider.oninput = function() {
        const threshold = parseFloat(this.value);
        document.getElementById('thresholdValue').innerText = threshold;
        updateProbability(finalPrices, threshold);
      };
    }

    function updateProbability(finalPrices, threshold) {
      const count = finalPrices.filter(price => price >= threshold).length;
      const probability = (count / finalPrices.length * 100).toFixed(2);
      document.getElementById('probability').innerText = probability + '%';
    }

    // 8. Plotting the Linear Trend Forecast
    function updateChartLinear(prices, futureDate, forecastPrice) {
      let trace1 = {
        x: prices.map(p => p.date),
        y: prices.map(p => p.close),
        mode: 'lines+markers',
        name: 'Historical Prices'
      };
      let lastDate = prices[prices.length - 1].date;
      let trace2 = {
        x: [lastDate, futureDate],
        y: [prices[prices.length - 1].close, forecastPrice],
        mode: 'lines+markers',
        name: 'Linear Trend Forecast'
      };
      let layout = {
        title: 'Linear Trend Forecast',
        xaxis: { title: 'Date' },
        yaxis: { title: 'Price' }
      };
      Plotly.newPlot('chart', [trace1, trace2], layout);
      document.getElementById('sliderDiv').style.display = 'none';
    }

    // 9. Plotting the Ensemble Forecast
    function updateChartEnsemble(finalPrices, lrForecast, ensembleForecast) {
      const trace = {
        x: finalPrices,
        type: 'histogram',
        marker: { color: '#7f7f7f' },
        name: 'Monte Carlo Simulation'
      };
      const layout = {
        title: 'Ensemble Forecast (Monte Carlo Histogram with LR & Ensemble Markers)',
        xaxis: { title: 'Price' },
        yaxis: { title: 'Frequency' },
        shapes: [
          {
            type: 'line',
            x0: lrForecast,
            x1: lrForecast,
            y0: 0,
            y1: Math.max(...finalPrices),
            line: { color: 'red', dash: 'dash' }
          },
          {
            type: 'line',
            x0: ensembleForecast,
            x1: ensembleForecast,
            y0: 0,
            y1: Math.max(...finalPrices),
            line: { color: 'blue', dash: 'dot' }
          }
        ]
      };
      Plotly.newPlot('chart', [trace], layout);

      document.getElementById('sliderDiv').style.display = 'block';
      const minPrice = Math.floor(Math.min(...finalPrices));
      const maxPrice = Math.ceil(Math.max(...finalPrices));
      const slider = document.getElementById('priceSlider');
      slider.min = minPrice;
      slider.max = maxPrice;
      slider.value = minPrice;
      document.getElementById('thresholdValue').innerText = minPrice;
      updateProbability(finalPrices, minPrice);
      slider.oninput = function() {
        const threshold = parseFloat(this.value);
        document.getElementById('thresholdValue').innerText = threshold;
        updateProbability(finalPrices, threshold);
      };
    }

    // 10. Explanation panel
    function generateExplanation(method, mcStats, lrResult, ensembleForecast) {
      let explanation = "<h3>Explanation of Results</h3>";
      explanation += "<p><strong>Data Source:</strong> Historical stock data is sourced from the Alpha Vantage API.</p>";
      if (method === "mc") {
        explanation += "<p><strong>Method:</strong> Monte Carlo Simulation using Geometric Brownian Motion (GBM).</p>";
        explanation += "<p>The simulation uses the formula:</p>";
        explanation += "<p style='font-style: italic;'>S<sub>T</sub> = S<sub>0</sub> × exp((μ - 0.5σ²)T + σ√T × Z)</p>";
        explanation += "<p>S<sub>0</sub> is the last observed price, μ is the (annualized) mean of log returns, σ is the (annualized) standard deviation, T is the time horizon (in years), and Z is a standard normal random variable.</p>";
      } else if (method === "lr") {
        explanation += "<p><strong>Method:</strong> Linear Trend Forecast using least squares regression.</p>";
        explanation += "<p>This method fits a line to the historical prices using the formula:</p>";
        explanation += "<p style='font-style: italic;'>Price = intercept + slope × (time in days)</p>";
        explanation += "<p>The line is then extrapolated to the selected future date.</p>";
      } else if (method === "ensemble") {
        explanation += "<p><strong>Method:</strong> Ensemble Forecast combining Monte Carlo Simulation (GBM) and Linear Trend Forecast.</p>";
        explanation += "<p>The ensemble forecast is computed as the average of the Monte Carlo forecast (using the mean of simulated prices) and the linear regression forecast.</p>";
      }
      if (lrResult) {
        explanation += `<p><strong>Linear Regression Details:</strong> Slope = ${lrResult.slope.toFixed(4)}, Intercept = ${lrResult.intercept.toFixed(4)}, Forecast Price = ${lrResult.forecastPrice.toFixed(2)}</p>`;
      }
      if (mcStats) {
        explanation += `<p><strong>Monte Carlo Simulation Details:</strong> Last Price = ${mcStats.lastPrice.toFixed(2)}, Mean Log Return = ${mcStats.mean.toFixed(4)}, Standard Deviation = ${mcStats.stdDev.toFixed(4)}</p>`;
      }
      if (method === "ensemble" && ensembleForecast) {
        explanation += `<p><strong>Ensemble Forecast Price:</strong> ${ensembleForecast.toFixed(2)}</p>`;
      }
      document.getElementById('explanation').innerHTML = explanation;
    }

    // 11. Main simulation event
    document.getElementById('simulateButton').addEventListener('click', async () => {
      document.getElementById('loading').style.display = 'block';
      const ticker = document.getElementById('ticker').value.trim();
      const periodMonths = parseInt(document.getElementById('period').value);
      const futureDateInput = document.getElementById('futureDate').value;
      const forecastMethod = document.getElementById('forecastMethod').value; // "mc", "lr", or "ensemble"
      
      if(!ticker || !futureDateInput) {
        alert("Please enter both a ticker symbol and a future date.");
        document.getElementById('loading').style.display = 'none';
        return;
      }
      
      try {
        // Fetch data from Alpha Vantage
        const timeSeries = await fetchHistoricalData(ticker);
        
        // Process data for the selected period
        const prices = processHistoricalData(timeSeries, periodMonths);
        if(prices.length < 2) {
          alert("Not enough historical data available for the specified period.");
          document.getElementById('loading').style.display = 'none';
          return;
        }
        
        // Convert future date input to a Date object
        const futureDate = new Date(futureDateInput);

        // Linear regression forecast
        const lrResult = linearRegressionForecast(prices, futureDate);
        
        let mcStats = null;
        let finalPrices = null;
        let ensembleForecast = null;
        
        // If method is MC or Ensemble, run Monte Carlo
        if(forecastMethod === "mc" || forecastMethod === "ensemble") {
          mcStats = computeStats(prices); // annualized stats
          
          // Time horizon (T in years)
          const lastDate = prices[prices.length - 1].date;
          const diffTime = Math.abs(futureDate - lastDate);
          const T = diffTime / (365 * 24 * 60 * 60 * 1000);
          
          finalPrices = runSimulation(mcStats.lastPrice, mcStats.mean, mcStats.stdDev, T);
        }
        
        // Update chart & explanation
        if(forecastMethod === "mc") {
          updateChartMC(finalPrices);
          generateExplanation("mc", mcStats, lrResult, null);
        } else if(forecastMethod === "lr") {
          updateChartLinear(prices, futureDate, lrResult.forecastPrice);
          generateExplanation("lr", null, lrResult, null);
        } else if(forecastMethod === "ensemble") {
          const mcMean = finalPrices.reduce((a, b) => a + b, 0) / finalPrices.length;
          ensembleForecast = (mcMean + lrResult.forecastPrice) / 2;
          updateChartEnsemble(finalPrices, lrResult.forecastPrice, ensembleForecast);
          generateExplanation("ensemble", mcStats, lrResult, ensembleForecast);
        }
      } catch (error) {
        alert("Error: " + error.message);
      }
      document.getElementById('loading').style.display = 'none';
    });
  </script>
</body>
</html>
